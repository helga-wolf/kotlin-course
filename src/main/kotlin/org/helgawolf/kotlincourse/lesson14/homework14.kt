package org.helgawolf.kotlincourse.lesson14

import org.helgawolf.kotlincourse.lessonsummaries.lesson11.searchKey

fun main() {

//Дан словарь с именем и временем выполнения каждого автоматизированного теста в секундах. Определите среднее время выполнения теста.

    val testsTime = mutableMapOf<String, Int>()
    var avg = testsTime.values.average()


//Имеется словарь с метаданными автоматизированных тестов, где ключи — это имена тестовых методов а значения - строка с метаданными. Выведите список всех тестовых методов.

    val metaDataList = mutableMapOf<String, String>("aaa" to "bbb")
    println( metaDataList.keys.toList())

//В изменяемый словарь с данными о прохождении тестов добавьте новый тест и его результат.

    val testResults = mutableMapOf<String, Boolean>()
    testResults.putAll(mapOf("test1" to true))

//Посчитайте количество успешных тестов в словаре с результатами.

    val successTests = testResults.count(){ it.value }

//Удалите из изменяемого словаря с баг-трекингом запись о баге, который был исправлен.

    val bugTracking = mutableMapOf<String, String>()
    bugTracking.remove("fixed")

//Для словаря с результатами тестирования веб-страниц (ключ — URL страницы, значение — статус ответа), выведите сообщение о странице и статусе её проверки.

    println(testResults.map(){"Страница ${it.key} проверилась с результатом ${it.value}"})

//Найдите в словаре с названием и временем ответа сервисов только те, время ответа которых превышает заданный порог.

    val responseTime = mapOf<String, Double>()
    responseTime.all {it.value > 4}

//В словаре хранятся результаты тестирования API (ключ — endpoint, значение — статус ответа в строке). Для указанного endpoint найдите статус ответа, если endpoint отсутствует, предположите, что он не был протестирован.

    val apiTests = mutableMapOf<String?, Int>("https://lol.kek" to 200, "https://kek.lol" to 500, null to 200)
    println( apiTests.toList())
    apiTests.filterKeys { it == null }


//Из словаря, содержащего конфигурации тестового окружения (ключ — название параметра конфигурации), получите значение для "browserType". Ответ не может быть null.

    val envConfig = mapOf<String, String?>("browserType" to "chrome")

    fun getBrowserTypeFromConfig(): String? {
        return envConfig["browserType"]?.toString() ?: throw IllegalArgumentException("Тип браузера не найден")
    }

//Создайте копию неизменяемого словаря с данными о версиях тестируемого ПО, чтобы добавить новую версию.

    val testedPO = mapOf<String, String>()
    val newTestedPO = testedPO + ("Windows" to "67")
    println(newTestedPO)

//Используя словарь с настройками тестирования для различных мобильных устройств (ключ — модель устройства), получите настройки для конкретной модели или верните настройки по умолчанию.

    val deviceModels = mapOf("айфон" to "тут настройки", "андроид" to "еще настройки")
    deviceModels.getOrDefault("айфон", "стандартные настройки")

//Проверьте, содержит ли словарь с ошибками тестирования (код и описание) определенный код ошибки.

    val errorTypes = mutableMapOf(404 to "not found", 500 to "internal server error", 403 to "forbidden")
    println(errorTypes.containsKey(419))

//Дан неизменяемый словарь, где ключи — это идентификаторы тестовых сценариев в формате "TestID_Version", а значения — статусы выполнения этих тестов ("Passed", "Failed", "Skipped"). Отфильтруйте словарь, оставив только те сценарии, идентификаторы которых соответствуют определённой версии тестов.

val testScenarios = mapOf("1_1" to "passed", "2_2" to "failed", "3_3" to "skipped")
    testScenarios.filterKeys { it == "3_3" }

//У вас есть словарь, где ключи — это названия функциональных модулей приложения, а значения — результаты их тестирования. Проверьте, есть ли модули с неудачным тестированием.

val moduleTests = mapOf<String, Boolean>()
    moduleTests.all { !it.value }

//Добавьте в изменяемый словарь с настройками тестовой среды настройки из другого словаря.
//
//Объедините два неизменяемых словаря с данными о багах.


//
//Очистите изменяемый словарь с временными данными о последнем прогоне автоматизированных тестов.
//
//Исключите из отчета по автоматизированному тестированию те случаи, где тесты были пропущены (имеют статус “skipped”)

    val autoTestReport = mutableMapOf<String, String>()
    autoTestReport.remove("skipped")

//Удалите из словаря с конфигурациями тестирования набор устаревших конфигураций.



//Создайте отчет о тестировании, преобразовав словарь с результатами тестирования (ключ — идентификатор теста, значение — результат) в список строк формата "Test ID: результат".

println( testResults.toString())

//Преобразуйте изменяемый словарь с результатами последнего тестирования в неизменяемый для архивации.
//
//Преобразуйте словарь, содержащий ID теста и данные о времени выполнения тестов, заменив идентификаторы тестов на их названия (название можно получить вызвав фейковый метод, например getNameById(id: String))
//
//Для словаря с оценками производительности различных версий приложения увеличьте каждую оценку на 10%, чтобы учесть новые условия тестирования.
//
//Проверьте, пуст ли словарь с ошибками компиляции тестов.

    val compilationErrors = mapOf<String, String>()
    compilationErrors.isEmpty()

//Убедитесь, что словарь с результатами нагрузочного тестирования не пуст.

    val loadTestResults = mapOf<String, String>()
    loadTestResults.isNotEmpty()

//Проверьте, прошли ли успешно все автоматизированные тесты в словаре с результатами.

    testResults.all() { !it.value }

//Определите, содержит ли словарь с результатами тестирования хотя бы один тест с ошибкой.

    testResults.any() { it.value }

//Отфильтруйте словарь с результатами тестирования сервисов, оставив только те тесты, которые не прошли успешно и содержат в названии “optional”.


}
